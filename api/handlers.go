// api/handlers.go
// Handling the API requests.


// Package api provides the functions implementations for API.
package api

import (
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"

    "receipt-processor/models"
    "receipt-processor/services"
    "receipt-processor/storage"

    "github.com/gorilla/mux"
)


// ValidationError represents an error that occurs during validation.
type ValidationError struct {
    Message string
}

// Error
// @Description    Return the error message.
// @Param          none
// @Return         error message: string
func (e *ValidationError) Error() string {
    return e.Message
}


// ProcessReceiptHandler
// @Description    Handle the POST /receipts/process endpoint.
// @Param          w: http.ResponseWriter, r: *http.Request
// @Return         none
func ProcessReceiptHandler(w http.ResponseWriter, r *http.Request) {
    defer r.Body.Close()

	// Decode the JSON request body
    var receipt models.Receipt
    err := json.NewDecoder(r.Body).Decode(&receipt)
    if err != nil {
        http.Error(w, "Invalid JSON format", http.StatusBadRequest)
        return
    }

    // Generate receipt ID based on content
    id, err := generateReceiptID(receipt)
    if err != nil {
        http.Error(w, "Error generating receipt ID", http.StatusInternalServerError)
        return
    }

    store := storage.GetStorageInstance()

    // Check if the receipt already exists - avoiding duplicate processing
    existingReceipt, exists := store.GetReceiptData(id)
	// If the receipt already exists, return the existing ID
    if exists {
		// if ID exists but the receipt data is different, return an conflict (hash collision) error
		// TODO: rare, might not be necessary.
		if !existingReceipt.Receipt.Equals(&receipt) {
			http.Error(w, "Hash collision detected, please try again", http.StatusConflict)
			return
		}

        // Receipt already processed, return existing ID
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"id": id})
        return
    }

    // If the receipt does not exist, calculate the points
    points, err := services.CalculateTotalPoints(&receipt)
    if err != nil {
        // If calculation fails, assume receipt is invalid
        http.Error(w, fmt.Sprintf("The receipt is invalid: %v", err), http.StatusBadRequest)
        return
    }

    // Store the receipt and points
    store.SaveReceipt(id, receipt, points)

    // Return the ID
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{"id": id})
}


// GetPointsHandler
// @Description    Handle the GET /receipts/{id}/points endpoint.
// @Param          w: http.ResponseWriter, r: *http.Request
// @Return         none
func GetPointsHandler(w http.ResponseWriter, r *http.Request) {
	// vars returns the route variables for the current request, if any.
    vars := mux.Vars(r)
    id := vars["id"]

    if id == "" || strings.TrimSpace(id) == "" {
        http.Error(w, "The ID of the receipt is required", http.StatusBadRequest)
        return
    }

    // Retrieve the receipt data
    data, exists := storage.GetStorageInstance().GetReceiptData(id)
    if !exists {
        http.Error(w, "No receipt found for that id", http.StatusNotFound)
        return
    }

    // Return the points
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]int64{"points": data.Points})
}

// generateReceiptID
// @Description    Generates a unique ID for the receipt based on its content.
//                 The ID is generated by hashing (SHA256) the receipt content to prevent duplicates. (instead of using UUID)
// @Param          receipt: models.Receipt
// @Return         receipt ID: string, error: error
//generates a unique ID for the receipt based on its content.
func generateReceiptID(receipt models.Receipt) (string, error) {
    // Marshal the receipt to JSON bytes
	// TODO: can preprocess the receipt like normalizing before hashing if needed
    receiptBytes, err := json.Marshal(receipt)
    if err != nil {
        return "", err
    }

    // Compute the SHA-256 hash of the receipt bytes
    hash := sha256.Sum256(receiptBytes)

    // Convert the hash to a hexadecimal string
    return hex.EncodeToString(hash[:]), nil
}